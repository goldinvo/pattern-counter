{"version":3,"sources":["components/PatternForm.js","Token.js","components/InstructionText.js","components/Counter.js","components/ManualCounter.js","components/InstructionView.js","PatternLexer.js","App.js","components/saucyboy.svg","components/Sidebar.js","index.js"],"names":["PatternForm","props","onSubmit","className","value","onChange","type","TokenType","Object","freeze","INSTR_CNT","INFO","NUM","STR","OPN_PAREN","CLS_PAREN","REP","SEP","mapToToken","str","match","tokenFactory","InstructionText","indicesToStyle","rejectNextClsParen","instruction","forEach","token","index","tokIndex","push","pop","colorIndex","clsParenColorStack","output","map","classes","includes","colors","length","Counter","color","htmlFor","name","maxLength","autoComplete","id","controls","ManualCounter","state","count","handleChange","bind","increment","reset","onKeyPressed","document","addEventListener","this","removeEventListener","e","target","tagName","key","ctrlKey","newCount","parseInt","setState","i","Number","style","display","justifyContent","onClick","Component","COLORS","FINISHED","InstructionView","finished","repeatCounters","repeats","repeatElement","numRepeats","event","onRepeatChange","PatternLexer","PTN_ERR","NO_INPUT","PAREN_MATCH","tokenize","rawPattern","ret","trim","split","filter","tokenString","tokenArr","tokType","caseOne","caseTwo","_stringsToTokens","isInvalid","pattern","parensMatch","reduce","numUnmatchedParens","advance","transState","instrIndex","slice","console","log","transNext","initInstr","initTok","initReps","JSON","parse","stringify","App","storedState","localStorage","getItem","patternInput","undefined","previousStates","initialize","handleFormChange","handleFormSubmit","next","nextInstruction","finishRepeat","addRepeat","handleRepeatChange","undo","saveAndDo","preventDefault","err","alert","prevState","repeatIndex","nextInstrIndex","newVal","newRepeats","func","saveState","storeState","setItem","Sidebar","title","description","info","href","src","logo","alt","ReactDOM","render","StrictMode","rel","getElementById"],"mappings":"6VAaeA,MAVf,SAAqBC,GACnB,OACE,uBAAMC,SAAUD,EAAMC,SAAUC,UAAU,cAA1C,UACE,0DACA,0BAAUC,MAAOH,EAAMG,MAAOC,SAAUJ,EAAMI,WAC9C,uBAAOC,KAAK,SAASF,MAAM,eCR3BG,EAAYC,OAAOC,OAAO,CAC9BC,UAAW,WACXC,KAAM,OACNC,IAAK,MACLC,IAAK,MACLC,UAAW,WACXC,UAAW,WACXC,IAAK,MACLC,IAAK,QAGP,SAASC,EAAWC,GAClB,OAAIA,EAAIC,MAAM,WAAmBb,EAAUG,UAClCS,EAAIC,MAAM,aAAqBb,EAAUI,KACjC,MAARQ,GAAuB,MAARA,GAAuB,MAARA,EAAoBZ,EAAUO,UACpD,MAARK,GAAuB,MAARA,GAAuB,MAARA,EAAoBZ,EAAUQ,UACpD,MAARI,EAAoBZ,EAAUS,IACtB,MAARG,GAAuB,MAARA,EAAoBZ,EAAUU,IAC7CE,EAAIC,MAAM,SAAiBb,EAAUK,IAClCL,EAAUM,IAIxB,IAAMQ,EAAe,SAACf,EAAMF,GAC1B,MAAO,CAACE,OAAMF,UCuCDkB,MAzDf,SAAyBrB,GAMvB,IAAIsB,EAAiB,GACjBC,EAAqB,EACzBvB,EAAMwB,YAAYC,SAAQ,SAACC,EAAOC,GAE5BD,EAAMrB,OAASC,EAAUO,UAC3Bc,EAAQ3B,EAAM4B,SAAWN,EAAeO,KAAKF,GAASJ,IAE7CG,EAAMrB,OAASC,EAAUQ,YAC9Ba,EAAQ3B,EAAM4B,SAChBN,EAAeQ,MAEfP,EAAqBA,IAAuBD,EAAeO,KAAKF,OAOtE,IAAII,EAAa,EACbC,EAAqB,GAErBC,EAASjC,EAAMwB,YAAYU,KAAK,SAACR,EAAOC,GAE1C,IAGIQ,EAHiBR,IAAU3B,EAAM4B,SAGR,eAAiB,GAe9C,OAjBqBN,EAAec,SAAST,KAKvCD,EAAMrB,OAASC,EAAUO,WAC3BsB,GAAWnC,EAAMqC,OAAON,GACxBC,EAAmBH,KAAK7B,EAAMqC,OAAON,IAEhCA,EAAa,EAAK/B,EAAMqC,OAAOC,QAAQP,KAG5CI,GAAWH,EAAmBF,OAK3B,sBAAM5B,UAAWiC,EAAjB,SAAuCT,EAAMvB,MAAQ,KAAtBwB,MAGxC,OACE,qBAAKzB,UAAU,kBAAf,SACG+B,K,MCnCQM,MAlBf,SAAiBvC,GACf,OACE,sBAAKE,UAAW,WAAaF,EAAMwC,MAAnC,UACE,iCACE,uBAAOC,QAAQ,eAAf,SAA+BzC,EAAM0C,OACrC,uBACErC,KAAK,OAAOsC,UAAU,IACtBC,aAAa,MACbC,GAAG,eACH1C,MAAOH,EAAMG,MACbC,SAAUJ,EAAMI,cAGnBJ,EAAM8C,SAAW9C,EAAM8C,SAAW,SCoE1BC,E,kDA7Eb,aAAe,IAAD,8BACZ,gBACKC,MAAQ,CACXC,MAAO,KAET,EAAKC,aAAe,EAAKA,aAAaC,KAAlB,gBACpB,EAAKC,UAAY,EAAKA,UAAUD,KAAf,gBACjB,EAAKE,MAAQ,EAAKA,MAAMF,KAAX,gBACb,EAAKG,aAAe,EAAKA,aAAaH,KAAlB,gBARR,E,qDAWd,WACEI,SAASC,iBAAiB,UAAWC,KAAKH,gB,kCAG5C,WACEC,SAASG,oBAAoB,UAAWD,KAAKH,gB,0BAI/C,SAAaK,GACX,GAAyB,aAArBA,EAAEC,OAAOC,QAEb,OAAOF,EAAEG,KACP,IAAK,IACEH,EAAEI,SAASN,KAAKL,UAAU,GAC/B,MACF,IAAK,IACHK,KAAKL,UAAU,IACf,MACF,QACE,U,0BAIN,SAAaO,GACX,IAAIK,EAAWL,EAAEC,OAAOzD,MACpB6D,EAAS7C,MAAM,QAInB6C,EAAWC,SAASD,GACpBP,KAAKS,SAAS,CACZjB,MAAOe,GAAsB,Q,uBAIjC,SAAUG,GACR,IAAIH,EAAWI,OAAOX,KAAKT,MAAMC,OAASkB,EAC1CV,KAAKS,SAAS,CACZjB,MAAOe,GAxDI,IAyDP,GAAKA,EACL,IAAMA,EA1DC,IA0DqB,O,mBAIpC,WACEP,KAAKS,SAAS,CAACjB,MAAO,Q,oBAGxB,WAAU,IAAD,OACDH,EACJ,sBAAKD,GAAG,WAAWwB,MAAO,CAACC,QAAS,OAAQC,eAAgB,UAA5D,UACE,wBAAQlE,KAAK,SAASmE,QAAS,kBAAM,EAAKpB,UAAU,IAApD,oBACA,wBAAQ/C,KAAK,SAASmE,QAAS,kBAAM,EAAKpB,UAAU,KAApD,qBACA,wBAAQ/C,KAAK,SAASmE,QAASf,KAAKJ,MAApC,sBAIJ,OACE,qBAAKnD,UAAU,iBAAf,SACE,cAAC,EAAD,CAASwC,KAAK,iBAAiBtC,SAAUqD,KAAKP,aAAc/C,MAAOsD,KAAKT,MAAMC,MAAOH,SAAUA,U,GAxE3E2B,aCDtBC,G,MAAS,CAAC,MAAO,SAAU,WAG3BC,EAAW,CAAC,CAACtE,KAAMC,EAAUM,IAAKT,MAAO,sBA4ChCyE,MAvCf,SAAyB5E,GACvB,GAAIA,EAAM6E,SACR,OAAO,cAAC,EAAD,CACLrD,YAAamD,EACb/C,SAAU,EACVS,OAAQqC,IAIZ,IAAII,EAAiB9E,EAAM+E,QAAQ7C,KAAK,SAAC8C,EAAerD,GACtD,IAAIa,EAAQb,EAAQ+C,EAAOpC,OAASoC,EAAO/C,GAAS+C,EAAOA,EAAOpC,OAAS,GAC3E,OACI,cAAC,EAAD,CAEAE,MAAOA,EACPE,KAAI,yBAAoBf,EAAQ,GAChCxB,MAAO6E,EAAcC,WACrB7E,SAAU,SAAC8E,GACTlF,EAAMmF,eAAexD,EAAOuD,KALzBvD,MAWX,OACE,sBAAKzB,UAAU,kBAAf,UACE,cAAC,EAAD,CACAsB,YAAaxB,EAAMwB,YACnBI,SAAU5B,EAAM4B,SAChBS,OAAQqC,IAER,sBAAKxE,UAAU,oBAAf,UACG4E,EACD,cAAC,EAAD,WC+DOM,EA5GO,WA8BpB,IAAMC,EAAU9E,OAAOC,OAAO,CAC5B8E,SAAU,yBACVC,YAAa,kFAoEf,MAAO,CACLC,SAlGF,SAAkBC,GAQhB,IAAIC,EAAMD,EACPE,OACAC,MAAM,MACNC,QAAO,SAAAnE,GAAK,MAAqB,KAAjBA,EAAMiE,UACtBzD,KAAI,SAAA4D,GACH,OAAOA,EACJH,OACAC,MAAM,kBACN1D,KAAI,SAAAR,GAAK,OAAIA,EAAMiE,UACnBE,QAAO,SAAAnE,GAAK,MAAc,KAAVA,QAOvB,OAFAgE,EAAMA,EAAIxD,KAAI,SAAA4D,GAAW,OAsC3B,SAA0BA,GACxB,IAAIC,EAAW,GACXpE,EAAQ,EAERV,EAAW6E,EAAY,GAAKA,EAAY,MAAQxF,EAAUG,YAC1DsF,EAASlE,KAAKT,EAAad,EAAUG,UAAWqF,EAAY,GAAKA,EAAY,KAC7EnE,GAAS,GAIb,KAAOA,EAAQmE,EAAYxD,QAAQ,CACjC,IAAM0D,EAAU/E,EAAW6E,EAAYnE,IAIvC,GAAIqE,IAAY1F,EAAUO,UAAW,CACnC,IAAMoF,EAAUH,EAAYnE,GAASmE,EAAYnE,EAAQ,GACnDuE,EAAUJ,EAAYnE,GAASmE,EAAYnE,EAAQ,GAAKmE,EAAYnE,EAAQ,GAClF,GAAIV,EAAWgF,KAAa3F,EAAUI,KAAM,CAC1CqF,EAASlE,KAAKT,EAAad,EAAUI,KAAMuF,IAC3CtE,GAAS,EACT,SACK,GAAIV,EAAWiF,KAAa5F,EAAUI,KAAM,CACjDqF,EAASlE,KAAKT,EAAad,EAAUI,KAAMwF,IAC3CvE,GAAS,EACT,UAKJoE,EAASlE,KAAKT,EAAa4E,EAASF,EAAYnE,KAChDA,IAGF,OAAOoE,EAxEsBI,CAAiBL,OA6E9CM,UAlEF,SAAmBC,GAGjB,IAAKA,EAAQ,KAAOA,EAAQ,GAAG,GAC7B,OAAOhB,EAAQC,SAIjB,IAAIgB,GAAc,EAclB,OAbAD,EAAQ5E,SAAS,SAAAD,GAUY,IATAA,EAAY+E,QAAQ,SAACC,EAAoB9E,GAMlE,OALIA,EAAMrB,OAASC,EAAUO,UAC3B2F,IACS9E,EAAMrB,OAASC,EAAUQ,WAClC0F,IAEKA,IACN,KAE2BF,GAAc,OAGvCA,GAAsBjB,EAAQE,aA6CrCF,WAvGkB,G,MC6VtB,SAASoB,EAAQC,GACf,IAtBoBlF,EAAaG,EAAOsD,EAsBnCoB,EAA2CK,EAA3CL,QAASM,EAAkCD,EAAlCC,WAAY/E,EAAsB8E,EAAtB9E,SAAUiD,EAAY6B,EAAZ7B,SAChCE,EAAU2B,EAAW3B,QAAQ6B,QAE7BP,EAAQM,GAAY/E,GAAUvB,OAASC,EAAUO,WAEnDkE,EAAQlD,KAAK,CAACF,MAAOC,EAAUqD,WAAY,IAC3CrD,KACSyE,EAAQM,GAAY/E,GAAUvB,OAASC,EAAUQ,WA7BxCU,EA+BD6E,EAAQM,GA/BMhF,EA+BOC,EA/BAqD,EA+BUF,EAAQA,EAAQzC,OAAS,GAAG2C,WA5B1EzD,EAAYG,GAAOtB,OAASC,EAAUQ,WAAW+F,QAAQC,IAAI,yBAG7DtF,EAAYG,EAAQ,IAAMH,EAAYG,EAAQ,GAAGtB,OAASC,EAAUS,MAKpES,EAAYG,EAAQ,IAAMH,EAAYG,EAAQ,GAAGtB,OAASC,EAAUK,KAC/DsE,EAAab,OAAO5C,EAAYG,EAAQ,GAAGxB,OAAS,GAqBzDyB,EAAWmD,EAAQA,EAAQzC,OAAO,GAAGX,MAAQ,EAC7CoD,EAAQA,EAAQzC,OAAS,GAAG2C,eAG5BF,EAAQjD,MACRF,MAIFA,IAGGyE,EAAQM,GAAY/E,KAEpB+E,GAAcN,EAAQ/D,OAAS,GAEhCV,EAAW8E,EAAW9E,SACtBmD,EAAU2B,EAAW3B,QAAQ6B,QAC7B/B,GAAW,IAEX8B,IACA/E,EAAW,IAIf8E,EAAWL,QAAUA,EACrBK,EAAWC,WAAaA,EACxBD,EAAW9E,SAAWA,EACtB8E,EAAW3B,QAAUA,EACrB2B,EAAW7B,SAAWA,EAMxB,SAASkC,EAAUL,GACjB,IAAMM,EAAYN,EAAWC,WACvBM,EAAUP,EAAW9E,SACrBsF,EAAWC,KAAKC,MAAMD,KAAKE,UAAUX,EAAW3B,UAEtD,GACE0B,EAAQC,SACDA,EAAWL,QAAQK,EAAWC,YAAYD,EAAW9E,UAAUvB,OAASC,EAAUM,MACrF8F,EAAW7B,UAEb6B,EAAW7B,WACb6B,EAAWC,WAAaK,EACxBN,EAAW9E,SAAWqF,EACtBP,EAAW3B,QAAUmC,GAIVI,M,kDAhYb,aAAe,IAAD,sBACZ,eAEA,IAAIC,EAAcJ,KAAKC,MAAMI,aAAaC,QAAQ,wBAHtC,OAIZ,EAAKzE,MAAQuE,GAA4B,CACvCG,aA5BW,+rBA6BXrB,aAASsB,EACThB,WAAY,EACZ/E,SAAU,EACViD,UAAU,EACVE,QAAS,GACT6C,eAAgB,IAIlB,EAAKC,WAAa,EAAKA,WAAW1E,KAAhB,gBAClB,EAAK2E,iBAAmB,EAAKA,iBAAiB3E,KAAtB,gBACxB,EAAK4E,iBAAmB,EAAKA,iBAAiB5E,KAAtB,gBACxB,EAAK6E,KAAO,EAAKA,KAAK7E,KAAV,gBACZ,EAAK8E,gBAAkB,EAAKA,gBAAgB9E,KAArB,gBACvB,EAAK+E,aAAe,EAAKA,aAAa/E,KAAlB,gBACpB,EAAKgF,UAAY,EAAKA,UAAUhF,KAAf,gBACjB,EAAKiF,mBAAqB,EAAKA,mBAAmBjF,KAAxB,gBAC1B,EAAKG,aAAe,EAAKA,aAAaH,KAAlB,gBACpB,EAAKkF,KAAO,EAAKA,KAAKlF,KAAV,gBACZ,EAAKmF,UAAY,EAAKA,UAAUnF,KAAf,gBAzBL,E,8CA4Bd,SAAWuE,GACTjE,KAAKS,SAAS,CACZwD,aAAcA,EACdrB,aAASsB,EACThB,WAAY,EACZ/E,SAAU,EACViD,UAAU,EACVE,QAAS,GACT6C,eAAgB,O,+BAIpB,WACErE,SAASC,iBAAiB,UAAWC,KAAKH,gB,kCAG5C,WACEC,SAASG,oBAAoB,UAAWD,KAAKH,gB,0BAI/C,SAAaK,GAEX,GAAyB,aAArBA,EAAEC,OAAOC,cAAiD8D,IAAvBlE,KAAKT,MAAMqD,QAElD,OAAO1C,EAAEG,KACP,IAAK,IACHH,EAAE4E,iBACF9E,KAAK6E,UAAU7E,KAAKuE,MACpB,MACF,IAAK,IACCvE,KAAKT,MAAM+B,QAAQzC,OAAS,GAAGmB,KAAK6E,UAAU7E,KAAK0E,WACvD,MACF,IAAK,IACC1E,KAAKT,MAAM+B,QAAQzC,OAAS,GAAGmB,KAAK6E,UAAU7E,KAAKyE,cACvD,MACF,IAAK,IACCvE,EAAEI,SAASN,KAAK4E,OACpB,MACF,QACE,U,8BAIN,SAAiB1E,GACfF,KAAKS,SAAS,CAACwD,aAAc/D,EAAEC,OAAOzD,U,8BAGxC,SAAiBwD,GAAI,IAAD,OAClBA,EAAE4E,iBAGF,IAAMlC,EAAUjB,EAAaI,SAAS/B,KAAKT,MAAM0E,cAC3Cc,EAAMpD,EAAagB,UAAUC,GAC/BmC,EACFC,MAAM,yBAA2BD,EAAM,KAIzC/E,KAAKS,SAAS,CACZmC,QAASA,IACR,WACGA,EAAQ,GAAG,GAAGhG,OAASC,EAAUM,KAAK,EAAKoH,Y,kBAOnD,WACEvE,KAAKS,UAAU,SAAAwE,GAEb,IAAIhC,EAAa,CACfL,QAASqC,EAAUrC,QACnBM,WAAY+B,EAAU/B,WACtB/E,SAAU8G,EAAU9G,SACpBmD,QAASoC,KAAKC,MAAMD,KAAKE,UAAUqB,EAAU3D,UAC7CF,SAAU6D,EAAU7D,UAKtB,OAFAkC,EAAUL,GAEH,eAAIA,Q,uBAMf,WAEEjD,KAAKS,UAAU,SAAAwE,GAEb,IAAIhC,EAAa,CACfL,QAASqC,EAAUrC,QACnBM,WAAY+B,EAAU/B,WACtB/E,SAAU8G,EAAU9G,SACpBmD,QAASoC,KAAKC,MAAMD,KAAKE,UAAUqB,EAAU3D,UAC7CF,SAAU6D,EAAU7D,UAGhB8D,EAAcjC,EAAW3B,QAAQzC,OAAS,EAC1C2C,EAAayB,EAAW3B,QAAQ4D,GAAa1D,WAEnD,GACE8B,EAAUL,UACFA,EAAW7B,UAChB6B,EAAW3B,QAAQ4D,IACnB1D,IAAeyB,EAAW3B,QAAQ4D,GAAa1D,YAEpD,OAAO,eAAIyB,Q,0BAMf,WAAgB,IAAD,OACPlF,EAAciC,KAAKT,MAAMqD,QAAQ5C,KAAKT,MAAM2D,YAC9CxC,EAAIV,KAAKT,MAAMpB,SACnB,GACEuC,UACO3C,EAAY2C,GAAG9D,OAASC,EAAUQ,WAC3CqD,IAGK3C,EAAY2C,GAUfV,KAAKS,SAAS,CACZtC,SAAUuC,EACVY,QAASoC,KAAKC,MAAMD,KAAKE,UAAU5D,KAAKT,MAAM+B,QAAQ6B,MAAM,GAAI,OAC/D,WACGpF,EAAY2C,GAAG9D,OAASC,EAAUM,KAAK,EAAKoH,UAZlDvE,KAAKS,SAAS,CACZyC,WAAYlD,KAAKT,MAAM2D,WAAa,EACpC/E,SAAU,EACVmD,QAAS,KACR,WACGvD,EAAY,EAAKwB,MAAM2D,YAAYtG,OAASC,EAAUM,KAAK,EAAKoH,Y,6BAa1E,WAAmB,IAAD,OACV3B,EAAU5C,KAAKT,MAAMqD,QAC3B,GAAG5C,KAAKT,MAAM2D,YAAcN,EAAQ/D,OAAS,EAE3CmB,KAAKS,SAAS,CAACW,UAAU,QAF3B,CAMA,IAAI+D,EAAiBnF,KAAKT,MAAM2D,WAAa,EAG7ClD,KAAKS,SAAS,CACZyC,WAAYiC,EACZhH,SAJiB,EAKjBmD,QAAS,KACR,WACGsB,EAAQuC,GAPK,GAOyBvI,OAASC,EAAUM,KAC3D,EAAKoH,a,gCAMX,SAAmBrG,EAAOuD,GACxB,IAAI2D,EAAS3D,EAAMtB,OAAOzD,MAC1B,IAAI0I,EAAO1H,MAAM,MAAjB,CAIA0H,EAAS5E,SAAS4E,GAElB,IAAIC,EAAa3B,KAAKC,MAAMD,KAAKE,UAAU5D,KAAKT,MAAM+B,UACtD+D,EAAWnH,GAAOsD,WAAa4D,GAAkB,EACjDpF,KAAKS,SAAS,CACZa,QAAS+D,O,uBAMb,SAAUC,GACRtF,KAAKuF,YACLD,IACAtF,KAAKwF,e,uBAIP,WACExF,KAAKS,UAAU,SAAAwE,GACb,IAAIhD,EAAMyB,KAAKC,MAAMD,KAAKE,UAAUqB,EAAUd,iBAQ9C,OAPAlC,EAAI7D,KAAK,CACP8E,WAAY+B,EAAU/B,WACtB/E,SAAU8G,EAAU9G,SACpBiD,SAAU6D,EAAU7D,SACpBE,QAASoC,KAAKC,MAAMD,KAAKE,UAAUqB,EAAU3D,YAGxC,CACL6C,eAAgBlC,Q,wBAMtB,WACE8B,aAAa0B,QAAQ,sBAAuB/B,KAAKE,UAAU5D,KAAKT,U,kBAIlE,WAAQ,IAAD,OACD4E,EAAiBT,KAAKC,MAAMD,KAAKE,UAAU5D,KAAKT,MAAM4E,iBAE1DnE,KAAKS,SAAL,2BACM0D,EAAe9F,OADrB,IAC4B8F,eAAgBA,KAC1C,kBAAM,EAAKqB,kB,oBAGf,WAAU,IAAD,OACP,YAA2BtB,IAAvBlE,KAAKT,MAAMqD,QAGX,8BACE,cAAC,EAAD,CAAalG,MAAOsD,KAAKT,MAAM0E,aAActH,SAAUqD,KAAKqE,iBAAkB7H,SAAUwD,KAAKsE,qBAIxFtE,KAAKT,MAAM6B,SAElB,gCACE,cAAC,EAAD,CAAiBA,UAAU,IAC3B,sBAAK3E,UAAU,cAAf,UACE,wBAAQsE,QAASf,KAAK4E,KAAtB,2BACA,wBAAQ7D,QAAS,kBAAM,EAAKqD,WAAW,EAAK7E,MAAM0E,eAAlD,2CAMJ,gCACE,8BACE,cAAC,EAAD,CACAlG,YAAaiC,KAAKT,MAAMqD,QAAQ5C,KAAKT,MAAM2D,YAC3C/E,SAAU6B,KAAKT,MAAMpB,SACrBmD,QAAStB,KAAKT,MAAM+B,QACpBI,eAAgB,SAACxD,EAAOuD,GAAR,OAAkB,EAAKoD,WAAU,kBAAM,EAAKF,mBAAmBzG,EAAOuD,OACtFL,SAAUpB,KAAKT,MAAM6B,aAGvB,sBAAK3E,UAAU,cAAf,UACE,wBAAQsE,QAAS,kBAAM,EAAK8D,UAAU,EAAKN,OAA3C,0BACCvE,KAAKT,MAAM+B,QAAQzC,OAAS,EAAI,wBAAQkC,QAAS,kBAAM,EAAK8D,UAAU,EAAKH,YAA3C,iCAAsF,KACtH1E,KAAKT,MAAM+B,QAAQzC,OAAS,EAAI,wBAAQkC,QAAS,kBAAM,EAAK8D,UAAU,EAAKJ,eAA3C,6BAAqF,QAExH,sBAAKhI,UAAU,cAAf,UACE,wBAAQsE,QAASf,KAAK4E,KAAtB,2BACA,wBAAQ7D,QAAS,kBAAM,EAAK8D,UAAU,EAAKL,kBAA3C,8BACA,wBAAQzD,QAAS,kBAAM,EAAKqD,WAAW,EAAK7E,MAAM0E,eAAlD,+C,GAjSMjD,aC/BH,MAA0B,qC,MCoB1B0E,MAhBf,SAAiBnJ,GACf,OACE,wBAAOE,UAAU,UAAjB,UACE,sBAAKA,UAAU,SAAf,UACE,qBAAK2C,GAAG,QAAR,SAAiB7C,EAAMoJ,QACvB,8BAAMpJ,EAAMqJ,cACZ,8BAAMrJ,EAAMsJ,UAEd,oBAAGC,KAAK,uBAAuBrJ,UAAU,OAAzC,UACE,qBAAKsJ,IAAKC,EAAMC,IAAI,KADtB,sBCJNC,IAASC,OACP,eAAC,IAAMC,WAAP,WACE,cAAC,EAAD,CACET,MAAM,kBACNC,YAAY,gEACZC,KACE,gCACE,oHAEW,mBAAGC,KAAK,uDAAuD3F,OAAO,SAASkG,IAAI,aAAnF,uBAFX,sCAIA,0JAMN,qBAAK5J,UAAU,UAAf,SAAyB,cAAC,EAAD,SAE3BqD,SAASwG,eAAe,W","file":"static/js/main.1ef442af.chunk.js","sourcesContent":["import './PatternForm.css'\n\n// props: onChange, onSubmit, value\nfunction PatternForm(props) {\n  return (\n    <form onSubmit={props.onSubmit} className='PatternForm'>\n      <label>Input Pattern Below: </label>\n      <textarea value={props.value} onChange={props.onChange} />\n      <input type=\"submit\" value=\"Submit\" />\n    </form>\n  );\n}\n\nexport default PatternForm;","const TokenType = Object.freeze({\n  INSTR_CNT: 'instrcnt', // 5. or 5)  (instruction number)\n  INFO: 'info', // (30)  (30 stitches for this round)\n  NUM: 'num', // 3\n  STR: 'str', // '4'\n  OPN_PAREN: 'opnparen', // (\n  CLS_PAREN: 'clsparen', // ) \n  REP: 'rep', // *\n  SEP: 'sep' // . or ,\n})\n\nfunction mapToToken(str) {\n  if (str.match(/^\\d+\\.$/)) return TokenType.INSTR_CNT; // special cases go first!!! 5) 5.  or  (info)\n  else if (str.match(/(\\(.*?\\))/)) return TokenType.INFO; \n  else if (str === '(' || str === '{' || str === '[') return TokenType.OPN_PAREN; // ( { [\n  else if (str === ')' || str === '}' || str === ']') return TokenType.CLS_PAREN; // ) ] }\n  else if (str === '*') return TokenType.REP;\n  else if (str === ',' || str === '.') return TokenType.SEP;\n  else if (str.match(/^\\d+$/)) return TokenType.NUM;\n  else return TokenType.STR;\n \n}\n\nconst tokenFactory = (type, value) => {\n  return {type, value};\n}\n\nexport {TokenType, mapToToken, tokenFactory};","import {TokenType} from '../Token'\n\n// The text view for the current line of instruction. Displays in bold the step of the instruction \n// you are currently on (according to tokIndex), and highlights different parenthesis pairs in different colors\n//\n// properties: instruction, tokIndex, colors (an array of the sequence of colors)\nfunction InstructionText(props) {\n\n  // Get list of the indices of the parentheses we need to color\n  //\n  // Go left to right adding to stack if valid. Keep rejectNextClsParen to remember to reject corresponding\n  // closing parenthesis from rejected open parenthesis.\n  let indicesToStyle = [];\n  let rejectNextClsParen = 0;\n  props.instruction.forEach((token, index) => {\n\n    if (token.type === TokenType.OPN_PAREN) {\n      index < props.tokIndex ? indicesToStyle.push(index) : rejectNextClsParen++;\n\n    } else if (token.type === TokenType.CLS_PAREN) {\n      if (index < props.tokIndex) {\n        indicesToStyle.pop();\n      } else {\n        rejectNextClsParen ? rejectNextClsParen-- : indicesToStyle.push(index);\n      }\n    }\n\n  });\n\n  // crete output as sequence of token values surrounded by styled spans\n  let colorIndex = 0; // index of color in input color array\n  let clsParenColorStack = []; // to match with corresponding open paren colors\n\n  let output = props.instruction.map( (token, index) => {\n\n    const currentInstr = index === props.tokIndex; // bold this\n    const coloredParen = indicesToStyle.includes(index); // color this\n\n    let classes = currentInstr ? 'focusedText ' : '';\n\n    if (coloredParen) {\n      if (token.type === TokenType.OPN_PAREN) {\n        classes += props.colors[colorIndex];\n        clsParenColorStack.push(props.colors[colorIndex]);\n        \n        if ((colorIndex + 1) < props.colors.length) colorIndex++; // if we used up all of the colors already, just stay at last color\n      } else {\n        // closed paren\n        classes += clsParenColorStack.pop();\n      }\n      \n    }\n\n    return <span className={classes} key={index}>{token.value + \" \"}</span>;\n  }) \n  \n  return (\n    <div className='instructionText'>\n      {output}\n    </div>\n  );\n}\n\nexport default InstructionText;","import React from 'react'\nimport './Counter.css'\n\n// Display for counts that can be changed by the user\n// props: name, onChange, value, color, controls (optional, for if you want buttons to interact with counter directly in component)\nfunction Counter(props) {\n  return (\n    <div className={'counter ' + props.color}>\n      <form>\n        <label htmlFor=\"counterInput\">{props.name}</label>\n        <input \n          type=\"text\" maxLength=\"3\"\n          autoComplete=\"off\"\n          id=\"counterInput\" \n          value={props.value}\n          onChange={props.onChange}\n        />\n      </form>\n      {props.controls ? props.controls : null}\n    </div>\n  );\n}\n\nexport default Counter;","import React, { Component } from \"react\";\nimport Counter from \"./Counter\"\n\nconst maxCount = 999;\n\n// an independent simple counter component with button controls for if the user wants to manually count something\n//\n// state: count is always a string that is either empty or represents a 3 digit whole number\nclass ManualCounter extends Component {\n  constructor() {\n    super();\n    this.state = {\n      count: '0',\n    }\n    this.handleChange = this.handleChange.bind(this);\n    this.increment = this.increment.bind(this);\n    this.reset = this.reset.bind(this);\n    this.onKeyPressed = this.onKeyPressed.bind(this);\n  }\n\n  componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyPressed);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyPressed);\n  }\n\n  // for keyboard shortcuts\n  onKeyPressed(e) {\n    if (e.target.tagName === 'TEXTAREA') return; // avoid accidental presses when inputting pattern\n    \n    switch(e.key) {\n      case \"z\":\n        if (!e.ctrlKey) this.increment(1); // avoid conflict with undo feature of main app\n        break;\n      case \"x\":\n        this.increment(10);\n        break;\n      default: \n        return;\n    }\n  }\n\n  handleChange(e) {\n    let newCount = e.target.value;\n    if (newCount.match(/\\D/)) {\n      // Don't accept non-numeric chars\n      return;\n    }    \n    newCount = parseInt(newCount); // NaN if empty string\n    this.setState({\n      count: newCount ? newCount : \"\", \n    })\n  }\n\n  increment(i) {\n    let newCount = Number(this.state.count) + i; // Number('') === 0\n    this.setState({\n      count: newCount <= maxCount \n        ? \"\" + newCount \n        : \"\" + (newCount - maxCount - 1),\n    })\n  }\n\n  reset(){\n    this.setState({count: '0'});\n  }\n\n  render() {\n    const controls = (\n      <div id='controls' style={{display: 'flex', justifyContent: 'center'}}>\n        <button type='button' onClick={() => this.increment(1)}>+1 (z)</button>\n        <button type='button' onClick={() => this.increment(10)}>+10 (x)</button>\n        <button type='button' onClick={this.reset}>Reset</button>\n      </div>\n    )\n    \n    return (\n      <div className='manual-counter'>\n        <Counter name=\"Manual Counter\" onChange={this.handleChange} value={this.state.count} controls={controls}/>\n      </div>\n    );\n  }\n}\n\nexport default ManualCounter;","import InstructionText from './InstructionText'\nimport Counter from './Counter'\nimport ManualCounter from './ManualCounter';\n\nimport './InstructionView.css'\nimport { TokenType } from '../Token';\n\nconst COLORS = ['red', 'orange', 'yellow'];\n\n// an instruction displayed when the pattern is finished\nconst FINISHED = [{type: TokenType.STR, value: \"Pattern Finished!\"}]\n\n// Create the instruction view based on the state of the pattern \n//\n// properties: instruction, tokIndex, repeats (array), onRepeatChange (handle change in # of repeats in counter), finished\nfunction InstructionView(props) {\n  if (props.finished) {\n    return <InstructionText \n      instruction={FINISHED}\n      tokIndex={0}\n      colors={COLORS}\n    />\n  }\n  \n  let repeatCounters = props.repeats.map( (repeatElement, index) => {\n    let color = index < COLORS.length ? COLORS[index] : COLORS[COLORS.length - 1];\n    return (\n        <Counter \n        key={index} \n        color={color} \n        name={`Repeat Counter ${index + 1}`} \n        value={repeatElement.numRepeats} \n        onChange={(event) => {\n          props.onRepeatChange(index, event);\n        }}\n        />\n    );\n  });\n   \n  return (\n    <div className='instructionView'>\n      <InstructionText \n      instruction={props.instruction}\n      tokIndex={props.tokIndex}\n      colors={COLORS}\n      />\n      <div className='countersContainer'>\n        {repeatCounters}\n        <ManualCounter />\n      </div>\n    </div>\n  );\n} \n\nexport default InstructionView;","import {TokenType, mapToToken, tokenFactory} from './Token'\n\n// A module for tokenization of user input and light validation of syntax.\nconst PatternLexer = (function() {\n\n  // create an array of token arrays that represent an individual instruction\n  function tokenize(rawPattern) {\n\n    // first, reduce in string form \n    // ex) `                            [\n    //     5. (SC 3, INC) * 6 (30)        [\"5\", \".\", \"(\", \"SC 3\", \",\", \"INC\", \")\", \"*\", \"6\", \"(\", \"30\", \")\"],\n    //     6. (SC 4, INC) * 6 (36)  ==>   [\"6\", \".\", \"(\", \"SC 4\", \",\", \"INC\", \")\", \"*\", \"6\", \"(\", \"36\", \")\"],\n    //     7. (SC 5, INC) * 6 (42)        [\"7\", \".\", \"(\", \"SC 5\", \",\", \"INC\", \")\", \"*\", \"6\", \"(\", \"42\", \")\"]\n    //     `                            ]\n    let ret = rawPattern\n      .trim()\n      .split(\"\\n\")                // analyze each line of pattern instruction separately (array of arrays)\n      .filter(token => token.trim() !== \"\")\n      .map(tokenString => {\n        return tokenString\n          .trim()   \n          .split(/([(){}[\\].,*])/) // separate all non-literal tokens (literals always surrounded by tokens/separators)\n          .map(token => token.trim())     // get rid of all whitespace\n          .filter(token => token !== \"\");\n      });\n\n\n    // next, convert from strings to tokens (do a little parsing here too for special elements)\n    ret = ret.map(tokenString => _stringsToTokens(tokenString)) \n\n    return ret;\n  }\n\n  const PTN_ERR = Object.freeze({\n    NO_INPUT: \"Please input a pattern\",\n    PAREN_MATCH: \"One of the instructions has a mismatched count of open and closed parenthesis\",\n  });\n\n  // basic validation for valid pattern instructions after tokenized\n  function isInvalid(pattern) {\n    \n    // did the user input a pattern?\n    if (!pattern[0] || !pattern[0][0]) {\n      return PTN_ERR.NO_INPUT;\n    }\n    \n    // is the number of parenthesis matched?\n    let parensMatch = true;\n    pattern.forEach( instruction => {\n      const numUnmatchedParens = instruction.reduce( (numUnmatchedParens, token) => {\n        if (token.type === TokenType.OPN_PAREN) {\n          numUnmatchedParens++;\n        } else if (token.type === TokenType.CLS_PAREN) {\n          numUnmatchedParens--;\n        }\n        return numUnmatchedParens;\n      }, 0 );\n\n      if (numUnmatchedParens !== 0) parensMatch = false;\n    })\n\n    return parensMatch ? false : PTN_ERR.PAREN_MATCH;\n  }\n\n  // takes an array of strings and maps it to its corresponding tokens.\n  // Not necessarily one-to-one: ex. '5', '.' => '5.' (instruction token)\n  function _stringsToTokens(tokenString) {\n    let tokenArr = [];\n    let index = 0; \n    // special case: step number  ex) 5.  or   5) at the beginning only\n    if (mapToToken(tokenString[0] + tokenString[1]) === TokenType.INSTR_CNT){\n        tokenArr.push(tokenFactory(TokenType.INSTR_CNT, tokenString[0] + tokenString[1]));\n        index += 2;\n    }\n    \n    // sequentially fill up with corresponding tokens \n    while (index < tokenString.length) {\n      const tokType = mapToToken(tokenString[index]);\n      \n      // special case for '(info)' token\n      // early break iff detect (info)\n      if (tokType === TokenType.OPN_PAREN) {\n        const caseOne = tokenString[index] + tokenString[index + 1]; // '()'\n        const caseTwo = tokenString[index] + tokenString[index + 1] + tokenString[index + 2]; // '(blahblah)'\n        if (mapToToken(caseOne) === TokenType.INFO) {\n          tokenArr.push(tokenFactory(TokenType.INFO, caseOne));\n          index += 2;\n          continue;\n        } else if (mapToToken(caseTwo) === TokenType.INFO) {\n          tokenArr.push(tokenFactory(TokenType.INFO, caseTwo));\n          index += 3;\n          continue;\n        }\n      } \n\n      // default case (not info)\n      tokenArr.push(tokenFactory(tokType, tokenString[index]))\n      index++;\n      \n    }\n    return tokenArr;\n  }\n\n  return {\n    tokenize,\n    isInvalid,\n    PTN_ERR,\n  }\n\n})();\n\nexport default PatternLexer;","import React, { Component } from \"react\";\nimport PatternForm from \"./components/PatternForm\";\nimport InstructionView from \"./components/InstructionView\";\nimport PatternLexer from \"./PatternLexer\";\nimport {TokenType} from './Token'\n\nimport './App.css';\n\n// these examples will be put below the form for the user to learn syntax\nconst EXAMPLE_TXT = `Press the 'Next' button or spacebar to advance!\n\n4. sc 3, hdc, dc 3, hdc, sc 3\n5. (sc 3, dc 5) * 3 (24 sts) (parenthesis without commas or periods are ignored)\n\nOn the next instruction try using the 'Complete Repeat' button! \n\n6. ((sc 2, dec, sc 2, dec) * 5, sc) * 3\n\nYou can also type into the counter display to edit counts directly!\n\n7. ((sc, dc, sc) * 594, sc 3, dc 2) * 2 (Click on the orange counter number and type in something else)\n\nSwitch to a G hook (Instructions don't have to start with a number)\n\nYou will need to use the 'Exit repeat' button in the next instruction\n\n8. (sc 3, picot) until end of row, sc, hdc, dc\n\nCut and weave in ends (Now try your own pattern!)\n`\n\nclass App extends Component {\n  constructor() {\n    super();\n    \n    let storedState = JSON.parse(localStorage.getItem('patternCounterState'));\n    this.state = storedState ? storedState : {\n      patternInput: EXAMPLE_TXT,\n      pattern: undefined,\n      instrIndex: 0,\n      tokIndex: 0,\n      finished: false,\n      repeats: [],     // {index, numRepeats}\n      previousStates: [], // {instrIndex, tokIndex, finished, repeats}\n    } \n\n\n    this.initialize = this.initialize.bind(this);\n    this.handleFormChange = this.handleFormChange.bind(this);\n    this.handleFormSubmit = this.handleFormSubmit.bind(this);\n    this.next = this.next.bind(this);\n    this.nextInstruction = this.nextInstruction.bind(this);\n    this.finishRepeat = this.finishRepeat.bind(this);\n    this.addRepeat = this.addRepeat.bind(this);\n    this.handleRepeatChange = this.handleRepeatChange.bind(this);\n    this.onKeyPressed = this.onKeyPressed.bind(this);\n    this.undo = this.undo.bind(this);\n    this.saveAndDo = this.saveAndDo.bind(this);\n  }\n\n  initialize(patternInput) {\n    this.setState({\n      patternInput: patternInput,\n      pattern: undefined,\n      instrIndex: 0,\n      tokIndex: 0,\n      finished: false,\n      repeats: [],\n      previousStates: [],\n    });\n  }\n\n  componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyPressed);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyPressed);\n  }\n\n  // for keyboard shortcuts\n  onKeyPressed(e) {\n    // ignore keys when inputting pattern\n    if (e.target.tagName === 'TEXTAREA' || this.state.pattern === undefined) return;\n    \n    switch(e.key) {\n      case \" \":\n        e.preventDefault();\n        this.saveAndDo(this.next);\n        break;\n      case \"c\":\n        if (this.state.repeats.length > 0) this.saveAndDo(this.addRepeat);\n        break;\n      case \"v\":\n        if (this.state.repeats.length > 0) this.saveAndDo(this.finishRepeat);\n        break;\n      case \"z\":\n        if (e.ctrlKey) this.undo();\n        break; \n      default: \n        return;\n    }\n  }\n  \n  handleFormChange(e) {\n    this.setState({patternInput: e.target.value});\n  }\n\n  handleFormSubmit(e) {\n    e.preventDefault();\n    \n    // is tokenized pattern valid(ish)?\n    const pattern = PatternLexer.tokenize(this.state.patternInput);\n    const err = PatternLexer.isInvalid(pattern);\n    if (err) {\n      alert(\"Pattern Syntax Error: \" + err + \".\");\n      return;\n    } \n\n    this.setState({\n      pattern: pattern,\n    }, () => {\n      if (pattern[0][0].type !== TokenType.STR) this.next(); // start on first string\n    }); \n    \n  }\n\n  // advance to next string. Use transState and transNext to quickly advance state multiple times\n  // synchronously. \n  next() {\n    this.setState( prevState => {\n\n      let transState = {\n        pattern: prevState.pattern,\n        instrIndex: prevState.instrIndex,\n        tokIndex: prevState.tokIndex,\n        repeats: JSON.parse(JSON.stringify(prevState.repeats)),\n        finished: prevState.finished,\n      }\n      \n      transNext(transState);\n\n      return {...transState};\n    });\n  }\n\n  // complete 1 repeat. Do this by advancing (next()) over and over until we see that the repeat\n  // array in state has changed. Use transState/transNext to quickly advance through state synchronously.\n  addRepeat() {\n    // go 'next()' until repeat status in state changes\n    this.setState( prevState => {\n\n      let transState = {\n        pattern: prevState.pattern,\n        instrIndex: prevState.instrIndex,\n        tokIndex: prevState.tokIndex,\n        repeats: JSON.parse(JSON.stringify(prevState.repeats)),\n        finished: prevState.finished,\n      }\n      \n      const repeatIndex = transState.repeats.length - 1;\n      const numRepeats = transState.repeats[repeatIndex].numRepeats;\n\n      do { \n        transNext(transState);\n      } while (!transState.finished \n        && transState.repeats[repeatIndex] \n        && numRepeats === transState.repeats[repeatIndex].numRepeats)\n\n      return {...transState};\n    });\n  }\n\n  // breka out of current repeat by setting current index ahead of next ')' and \n  // popping the repeat stack.\n  finishRepeat() {\n    const instruction = this.state.pattern[this.state.instrIndex];\n    let i = this.state.tokIndex;\n    do {\n      i++\n    } while (instruction[i].type !== TokenType.CLS_PAREN);\n    i++\n\n    // instruction[i] is token directly after ')'. move on to next token/instruction and pop repeat stack.\n    if (!instruction[i]) {\n      // need to move on to next instruction\n      this.setState({\n        instrIndex: this.state.instrIndex + 1,\n        tokIndex: 0,\n        repeats: [],\n      }, () => {\n        if (instruction[this.state.instrIndex].type !== TokenType.STR) this.next(); // leave us off at next string\n      })\n    } else {\n      this.setState({\n        tokIndex: i,\n        repeats: JSON.parse(JSON.stringify(this.state.repeats.slice(0, -1))),\n      }, () => {\n        if (instruction[i].type !== TokenType.STR) this.next(); // leave us off at next string\n      })\n    }\n  }\n\n  // skip to next instruction in the pattern\n  nextInstruction() {\n    const pattern = this.state.pattern;\n    if(this.state.instrIndex >= pattern.length - 1) {\n      // already at last pattern\n      this.setState({finished: true});\n      return;\n    }\n\n    let nextInstrIndex = this.state.instrIndex + 1;\n    let nextTokIndex = 0;\n    \n    this.setState({\n      instrIndex: nextInstrIndex,\n      tokIndex: nextTokIndex,\n      repeats: [],\n    }, () => {\n      if (pattern[nextInstrIndex][nextTokIndex].type !== TokenType.STR) {\n        this.next(); // start at first string\n      }\n    })\n  }\n\n  // change count inside of repeats[index] when user manually changes it.\n  handleRepeatChange(index, event) {\n    let newVal = event.target.value;\n    if (newVal.match(/\\D/)) {\n      // Don't accept non-numeric chars\n      return;\n    }   \n    newVal = parseInt(newVal); // NaN if empty string\n\n    let newRepeats = JSON.parse(JSON.stringify(this.state.repeats));\n    newRepeats[index].numRepeats = newVal ? newVal : 0;\n    this.setState({\n      repeats: newRepeats,\n    })\n    return;\n  }\n\n  // Save state only when user directly interact with methods.\n  saveAndDo(func) {\n    this.saveState();\n    func();\n    this.storeState();\n  }\n\n  // save relevant parts of state in previousStates stack for undo();\n  saveState() {\n    this.setState( prevState => {\n      let ret = JSON.parse(JSON.stringify(prevState.previousStates));\n      ret.push({\n        instrIndex: prevState.instrIndex,\n        tokIndex: prevState.tokIndex,\n        finished: prevState.finished,\n        repeats: JSON.parse(JSON.stringify(prevState.repeats)),\n      })\n\n      return {\n        previousStates: ret,\n      }\n    })\n  }\n\n  // save the current state using web storage api\n  storeState() {\n    localStorage.setItem('patternCounterState', JSON.stringify(this.state));\n  }\n\n  // restore state to top of previousState stack\n  undo() {\n    let previousStates = JSON.parse(JSON.stringify(this.state.previousStates));\n    \n    this.setState(\n      {...previousStates.pop(), previousStates: previousStates} // [].pop() undefined\n    , () => this.storeState())\n  }\n\n  render() {\n    if (this.state.pattern === undefined) {\n      // user needs to input pattern\n      return (\n        <div>\n          <PatternForm value={this.state.patternInput} onChange={this.handleFormChange} onSubmit={this.handleFormSubmit}/>\n        </div>\n      )\n\n    } else if (this.state.finished) {\n      return (\n        <div>\n          <InstructionView finished={true}/> \n          <div className='button-menu'>\n            <button onClick={this.undo}>Undo (ctrl-z)</button>\n            <button onClick={() => this.initialize(this.state.patternInput)}>Submit Anonther Pattern</button>\n          </div>\n        </div>\n      )\n    } else {\n      return (\n        <div>\n          <div>\n            <InstructionView \n            instruction={this.state.pattern[this.state.instrIndex]} \n            tokIndex={this.state.tokIndex} \n            repeats={this.state.repeats} \n            onRepeatChange={(index, event) => this.saveAndDo(() => this.handleRepeatChange(index, event))}\n            finished={this.state.finished}\n            />\n          </div>\n          <div className='button-menu'>\n            <button onClick={() => this.saveAndDo(this.next)}>Next (Space)</button>\n            {this.state.repeats.length > 0 ? <button onClick={() => this.saveAndDo(this.addRepeat)}>Complete Repeat (c)</button> : null}\n            {this.state.repeats.length > 0 ? <button onClick={() => this.saveAndDo(this.finishRepeat)}>Exit repeat (v)</button> : null}\n          </div>\n          <div className='button-menu'>\n            <button onClick={this.undo}>Undo (ctrl-z)</button>\n            <button onClick={() => this.saveAndDo(this.nextInstruction)}>Next Instruction</button>\n            <button onClick={() => this.initialize(this.state.patternInput)}>Submit Anonther Pattern</button>\n          </div>\n        </div>\n      )\n    }\n  }\n}\n\n// ====== static methods ======\n\n// Call when we are at a ')' to see if we are ready to finish repeating\nfunction needToRepeat(instruction, index, numRepeats) {\n  \n  // assumes we are at ')' token\n  if (instruction[index].type !== TokenType.CLS_PAREN) console.log(\"fxn needToRepeat!!!!!\");\n  \n  // if no multiplier, repeat indefinitely within ()'s\n  if (instruction[index + 1] && instruction[index + 1].type !== TokenType.REP) {\n    return true;\n  }\n  \n  // do we have (sequence) * NUM ?\n  if (instruction[index + 2] && instruction[index + 2].type === TokenType.NUM) {\n    return numRepeats < Number(instruction[index + 2].value) - 1;\n  }\n  \n  // we don't have (sequence) * NUM\n  return true;\n}\n\n// advances to next token using repeat logic. if no next token, go to next instruction.\n// 'static' method. mutates transState to avoid problems with asynchronous setState.\nfunction advance(transState) {\n  let {pattern, instrIndex, tokIndex, finished} = transState;\n  let repeats = transState.repeats.slice();\n\n  if (pattern[instrIndex][tokIndex].type === TokenType.OPN_PAREN) {\n    // '(': create new repeat\n    repeats.push({index: tokIndex, numRepeats: 0});\n    tokIndex++;\n  } else if (pattern[instrIndex][tokIndex].type === TokenType.CLS_PAREN) {\n    // ')' do we continue or repeat?\n    if (needToRepeat(pattern[instrIndex], tokIndex, repeats[repeats.length - 1].numRepeats)){\n      // go back to beginning of repeat\n      tokIndex = repeats[repeats.length-1].index + 1;\n      repeats[repeats.length - 1].numRepeats++;\n    } else {\n      // finish repeat\n      repeats.pop();\n      tokIndex++;\n    }\n\n  } else {\n    tokIndex++;\n  }\n\n  if (!pattern[instrIndex][tokIndex]) {\n    // need to move on to next instruction\n    if(instrIndex >= pattern.length - 1) {\n      // already on last instruction\n      tokIndex = transState.tokIndex;\n      repeats = transState.repeats.slice();\n      finished = true;\n    } else {\n      instrIndex++;\n      tokIndex = 0;\n    }\n  }\n\n  transState.pattern = pattern;\n  transState.instrIndex = instrIndex;\n  transState.tokIndex = tokIndex;\n  transState.repeats = repeats;\n  transState.finished = finished;\n\n}\n\n// advances to next string \n// 'static' method. mutates transState to avoid problems with asynchronous setState.\nfunction transNext(transState) {\n  const initInstr = transState.instrIndex;\n  const initTok = transState.tokIndex;\n  const initReps = JSON.parse(JSON.stringify(transState.repeats));\n  \n  do {\n    advance(transState);\n  } while (transState.pattern[transState.instrIndex][transState.tokIndex].type !== TokenType.STR\n    && !transState.finished);\n\n  if (transState.finished) {\n    transState.instrIndex = initInstr;\n    transState.tokIndex = initTok;\n    transState.repeats = initReps;\n  }\n} \n\nexport default App;\n","export default __webpack_public_path__ + \"static/media/saucyboy.1dc1fe53.svg\";","import logo from './saucyboy.svg'\nimport './Sidebar.css'\n\n// props: title, description, info\nfunction Sidebar(props) {\n  return (\n    <aside className='sidebar'>\n      <div className='header'>\n        <div id='title'>{props.title}</div>\n        <div>{props.description}</div>  \n        <div>{props.info}</div>\n      </div>\n      <a href='https://goldinvo.com' className='link'>\n        <img src={logo} alt=''></img>\n        goldinvo.com\n      </a>\n    </aside>\n  )\n}\n\nexport default Sidebar;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport Sidebar from './components/Sidebar'\n\n// import tester from './tester';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Sidebar \n      title='Pattern Counter'\n      description='Keep track of your place in your knitting or crochet pattern!'\n      info={\n        <div>\n          <p>\n            Start by putting inputting your pattern using the pattern counter syntax. \n            Visit my <a href='https://goldinvo.com/2021/07/22/pattern-counter.html' target='_blank' rel=\"noreferrer\">blog post</a> for examples and usage details.\n          </p>\n          <p>\n            Please send any questions, comments/feedback, or bug reports my way! I would much appreciate it: goldin@goldinvo.com\n          </p>\n        </div>   \n      }\n    />\n    <div className='content'><App /></div>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// tester();\n"],"sourceRoot":""}