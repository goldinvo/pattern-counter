{"version":3,"sources":["components/PatternForm.js","Token.js","components/InstructionText.js","components/Counter.js","components/ManualCounter.js","components/InstructionView.js","PatternLexer.js","App.js","index.js"],"names":["PatternForm","props","onSubmit","className","value","onChange","type","TokenType","Object","freeze","INSTR_CNT","INFO","NUM","STR","OPN_PAREN","CLS_PAREN","REP","SEP","mapToToken","str","match","tokenFactory","InstructionText","indicesToStyle","rejectNextClsParen","instruction","forEach","token","index","tokIndex","push","pop","colorIndex","clsParenColorStack","output","map","classes","includes","colors","length","Counter","color","htmlFor","name","maxLength","autoComplete","id","controls","ManualCounter","state","count","handleChange","bind","increment","reset","onKeyPressed","document","addEventListener","this","removeEventListener","e","target","tagName","key","newCount","parseInt","setState","i","Number","style","display","justifyContent","onClick","Component","COLORS","InstructionView","repeatCounters","repeats","repeatElement","numRepeats","event","onRepeatChange","PatternLexer","PTN_ERR","NO_INPUT","PAREN_MATCH","tokenize","rawPattern","ret","trim","split","filter","tokenString","tokenArr","tokType","caseOne","caseTwo","_stringsToTokens","isInvalid","pattern","parensMatch","reduce","numUnmatchedParens","advance","transState","instrIndex","finished","slice","console","log","transNext","initInstr","initTok","initReps","JSON","parse","stringify","App","patternInput","undefined","handleFormChange","handleFormSubmit","next","nextInstruction","finishRepeat","addRepeat","handleRepeatChange","preventDefault","err","alert","prevState","repeatIndex","nextInstrIndex","newVal","newRepeats","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.91dbe896.chunk.js","sourcesContent":["import './PatternForm.css'\n\n// props: onChange, onSubmit, value\nfunction PatternForm(props) {\n  return (\n    <form onSubmit={props.onSubmit} className='PatternForm'>\n      <label>Input Pattern Below: </label>\n      <textarea value={props.value} onChange={props.onChange} />\n      <input type=\"submit\" value=\"Submit\" />\n    </form>\n  );\n}\n\nexport default PatternForm;","const TokenType = Object.freeze({\n  INSTR_CNT: 'instrcnt', // 5. or 5)  (instruction number)\n  INFO: 'info', // (30)  (30 stitches for this round)\n  NUM: 'num', // 3\n  STR: 'str', // '4'\n  OPN_PAREN: 'opnparen', // (\n  CLS_PAREN: 'clsparen', // ) \n  REP: 'rep', // *\n  SEP: 'sep' // . or ,\n})\n\nfunction mapToToken(str) {\n  if (str.match(/^\\d+\\.$/)) return TokenType.INSTR_CNT; // special cases go first!!! 5) 5.  or  (info)\n  else if (str.match(/(\\(.*?\\))/)) return TokenType.INFO; \n  else if (str === '(' || str === '{' || str === '[') return TokenType.OPN_PAREN; // ( { [\n  else if (str === ')' || str === '}' || str === ']') return TokenType.CLS_PAREN; // ) ] }\n  else if (str === '*') return TokenType.REP;\n  else if (str === ',' || str === '.') return TokenType.SEP;\n  else if (str.match(/^\\d+$/)) return TokenType.NUM;\n  else return TokenType.STR;\n \n}\n\nconst tokenFactory = (type, value) => {\n  return {type, value};\n}\n\nexport {TokenType, mapToToken, tokenFactory};","import {TokenType} from '../Token'\n\n// The text view for the current line of instruction. Displays in bold the step of the instruction \n// you are currently on (according to tokIndex), and highlights different parenthesis pairs in different colors\n//\n// properties: instruction, tokIndex, colors (an array of the sequence of colors)\nfunction InstructionText(props) {\n\n  // Get list of the indices of the parentheses we need to color\n  //\n  // Go left to right adding to stack if valid. Keep rejectNextClsParen to remember to reject corresponding\n  // closing parenthesis from rejected open parenthesis.\n  let indicesToStyle = [];\n  let rejectNextClsParen = 0;\n  props.instruction.forEach((token, index) => {\n\n    if (token.type === TokenType.OPN_PAREN) {\n      index < props.tokIndex ? indicesToStyle.push(index) : rejectNextClsParen++;\n\n    } else if (token.type === TokenType.CLS_PAREN) {\n      if (index < props.tokIndex) {\n        indicesToStyle.pop();\n      } else {\n        rejectNextClsParen ? rejectNextClsParen-- : indicesToStyle.push(index);\n      }\n    }\n\n  });\n\n  // crete output as sequence of token values surrounded by styled spans\n  let colorIndex = 0; // index of color in input color array\n  let clsParenColorStack = []; // to match with corresponding open paren colors\n\n  let output = props.instruction.map( (token, index) => {\n\n    const currentInstr = index === props.tokIndex; // bold this\n    const coloredParen = indicesToStyle.includes(index); // color this\n\n    let classes = currentInstr ? 'focusedText ' : '';\n\n    if (coloredParen) {\n      if (token.type === TokenType.OPN_PAREN) {\n        classes += props.colors[colorIndex];\n        clsParenColorStack.push(props.colors[colorIndex]);\n        \n        if ((colorIndex + 1) < props.colors.length) colorIndex++; // if we used up all of the colors already, just stay at last color\n      } else {\n        // closed paren\n        classes += clsParenColorStack.pop();\n      }\n      \n    }\n\n    return <span className={classes} key={index}>{token.value + \" \"}</span>;\n  }) \n  \n  return (\n    <div className='instructionText'>\n      {output}\n    </div>\n  );\n}\n\nexport default InstructionText;","import './Counter.css'\n\n// Display for counts that can be changed by the user\n// props: name, onChange, value, color, controls (optional, for if you want buttons to interact with counter directly in component)\nfunction Counter(props) {\n  return (\n    <div className={'counter ' + props.color}>\n      <form>\n        <label htmlFor=\"counterInput\">{props.name}</label>\n        <input \n          type=\"text\" maxLength=\"3\"\n          autoComplete=\"off\"\n          id=\"counterInput\" \n          value={props.value}\n          onChange={props.onChange}\n        />\n      </form>\n      {props.controls ? props.controls : null}\n    </div>\n  );\n}\n\nexport default Counter;","import React, { Component } from \"react\";\nimport Counter from \"./Counter\"\n\nconst maxCount = 999;\n\n// an independent simple counter component with button controls for if the user wants to manually count something\n//\n// state: count is always a string that is either empty or represents a 3 digit whole number\nclass ManualCounter extends Component {\n  constructor() {\n    super();\n    this.state = {\n      count: '0',\n    }\n    this.handleChange = this.handleChange.bind(this);\n    this.increment = this.increment.bind(this);\n    this.reset = this.reset.bind(this);\n    this.onKeyPressed = this.onKeyPressed.bind(this);\n  }\n\n  componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyPressed);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyPressed);\n  }\n\n  // for keyboard shortcuts\n  onKeyPressed(e) {\n    if (e.target.tagName === 'TEXTAREA') return; // avoid accidental presses when inputting pattern\n    \n    switch(e.key) {\n      case \"z\":\n        this.increment(1);\n        break;\n      case \"x\":\n        this.increment(10);\n        break;\n      default: \n        return;\n    }\n  }\n\n  handleChange(e) {\n    let newCount = e.target.value;\n    if (newCount.match(/\\D/)) {\n      // Don't accept non-numeric chars\n      return;\n    }    \n    newCount = parseInt(newCount); // NaN if empty string\n    this.setState({\n      count: newCount ? newCount : \"\", \n    })\n  }\n\n  increment(i) {\n    let newCount = Number(this.state.count) + i; // Number('') === 0\n    this.setState({\n      count: newCount <= maxCount \n        ? \"\" + newCount \n        : \"\" + (newCount - maxCount - 1),\n    })\n  }\n\n  reset(){\n    this.setState({count: '0'});\n  }\n\n  render() {\n    const controls = (\n      <div id='controls' style={{display: 'flex', justifyContent: 'center'}}>\n        <button type='button' onClick={() => this.increment(1)}>+1 (z)</button>\n        <button type='button' onClick={() => this.increment(10)}>+10 (x)</button>\n        <button type='button' onClick={this.reset}>Reset</button>\n      </div>\n    )\n    \n    return (\n      <div className='manual-counter'>\n        <Counter name=\"Manual Counter\" onChange={this.handleChange} value={this.state.count} controls={controls}/>\n      </div>\n    );\n  }\n}\n\nexport default ManualCounter;","import InstructionText from './InstructionText'\nimport Counter from './Counter'\nimport ManualCounter from './ManualCounter';\n\nimport './InstructionView.css';\n\nconst COLORS = ['red', 'orange', 'yellow'];\n\n// Create the instruction view based on the state of the pattern \n//\n// properties: instruction, tokIndex, repeats (array), onRepeatChange (handle change in # of repeats in counter)\nfunction InstructionView(props) {\n  let repeatCounters = props.repeats.map( (repeatElement, index) => {\n    let color = index < COLORS.length ? COLORS[index] : COLORS[COLORS.length - 1];\n    return (\n        <Counter \n        key={index} \n        color={color} \n        name={`Repeat Counter ${index + 1}`} \n        value={repeatElement.numRepeats} \n        onChange={(event) => {\n          props.onRepeatChange(index, event);\n        }}\n        />\n    );\n  });\n   \n  return (\n    <div className='instructionView'>\n      <InstructionText \n      instruction={props.instruction}\n      tokIndex={props.tokIndex}\n      colors={COLORS}\n      />\n      <div className='countersContainer'>\n        {repeatCounters}\n        <ManualCounter />\n      </div>\n    </div>\n  );\n} \n\nexport default InstructionView;","import {TokenType, mapToToken, tokenFactory} from './Token'\n\n// A module for tokenization of user input and light validation of syntax.\nconst PatternLexer = (function() {\n\n  // create an array of token arrays that represent an individual instruction\n  function tokenize(rawPattern) {\n\n    // first, reduce in string form \n    // ex) `                            [\n    //     5. (SC 3, INC) * 6 (30)        [\"5\", \".\", \"(\", \"SC 3\", \",\", \"INC\", \")\", \"*\", \"6\", \"(\", \"30\", \")\"],\n    //     6. (SC 4, INC) * 6 (36)  ==>   [\"6\", \".\", \"(\", \"SC 4\", \",\", \"INC\", \")\", \"*\", \"6\", \"(\", \"36\", \")\"],\n    //     7. (SC 5, INC) * 6 (42)        [\"7\", \".\", \"(\", \"SC 5\", \",\", \"INC\", \")\", \"*\", \"6\", \"(\", \"42\", \")\"]\n    //     `                            ]\n    let ret = rawPattern\n      .trim()\n      .split(\"\\n\")                // analyze each line of pattern instruction separately (array of arrays)\n      .filter(token => token.trim() !== \"\")\n      .map(tokenString => {\n        return tokenString\n          .trim()   \n          .split(/([(){}[\\].,*])/) // separate all non-literal tokens (literals always surrounded by tokens/separators)\n          .map(token => token.trim())     // get rid of all whitespace\n          .filter(token => token !== \"\");\n      });\n\n\n    // next, convert from strings to tokens (do a little parsing here too for special elements)\n    ret = ret.map(tokenString => _stringsToTokens(tokenString)) \n\n    return ret;\n  }\n\n  const PTN_ERR = Object.freeze({\n    NO_INPUT: \"Please input a pattern\",\n    PAREN_MATCH: \"One of the instructions has a mismatched count of open and closed parenthesis\",\n  });\n\n  // basic validation for valid pattern instructions after tokenized\n  function isInvalid(pattern) {\n    \n    // did the user input a pattern?\n    if (!pattern[0] || !pattern[0][0]) {\n      return PTN_ERR.NO_INPUT;\n    }\n    \n    // is the number of parenthesis matched?\n    let parensMatch = true;\n    pattern.forEach( instruction => {\n      const numUnmatchedParens = instruction.reduce( (numUnmatchedParens, token) => {\n        if (token.type === TokenType.OPN_PAREN) {\n          numUnmatchedParens++;\n        } else if (token.type === TokenType.CLS_PAREN) {\n          numUnmatchedParens--;\n        }\n        return numUnmatchedParens;\n      }, 0 );\n\n      if (numUnmatchedParens !== 0) parensMatch = false;\n    })\n\n    return parensMatch ? false : PTN_ERR.PAREN_MATCH;\n  }\n\n  // takes an array of strings and maps it to its corresponding tokens.\n  // Not necessarily one-to-one: ex. '5', '.' => '5.' (instruction token)\n  function _stringsToTokens(tokenString) {\n    let tokenArr = [];\n    let index = 0; \n    // special case: step number  ex) 5.  or   5) at the beginning only\n    if (mapToToken(tokenString[0] + tokenString[1]) === TokenType.INSTR_CNT){\n        tokenArr.push(tokenFactory(TokenType.INSTR_CNT, tokenString[0] + tokenString[1]));\n        index += 2;\n    }\n    \n    // sequentially fill up with corresponding tokens \n    while (index < tokenString.length) {\n      const tokType = mapToToken(tokenString[index]);\n      \n      // special case for '(info)' token\n      // early break iff detect (info)\n      if (tokType === TokenType.OPN_PAREN) {\n        const caseOne = tokenString[index] + tokenString[index + 1]; // '()'\n        const caseTwo = tokenString[index] + tokenString[index + 1] + tokenString[index + 2]; // '(blahblah)'\n        if (mapToToken(caseOne) === TokenType.INFO) {\n          tokenArr.push(tokenFactory(TokenType.INFO, caseOne));\n          index += 2;\n          continue;\n        } else if (mapToToken(caseTwo) === TokenType.INFO) {\n          tokenArr.push(tokenFactory(TokenType.INFO, caseTwo));\n          index += 3;\n          continue;\n        }\n      } \n\n      // default case (not info)\n      tokenArr.push(tokenFactory(tokType, tokenString[index]))\n      index++;\n      \n    }\n    return tokenArr;\n  }\n\n  return {\n    tokenize,\n    isInvalid,\n    PTN_ERR,\n  }\n\n})();\n\nexport default PatternLexer;","import React, { Component } from \"react\";\nimport PatternForm from \"./components/PatternForm\";\nimport InstructionView from \"./components/InstructionView\";\nimport PatternLexer from \"./PatternLexer\";\nimport {TokenType} from './Token'\n\nimport './App.css';\n\nclass App extends Component {\n  constructor() {\n    super();\n    this.state = {\n      patternInput: \"\",\n      pattern: undefined,\n      instrIndex: 0,\n      tokIndex: 0,\n      finished: false,\n      repeats: [],\n    }\n    this.handleFormChange = this.handleFormChange.bind(this);\n    this.handleFormSubmit = this.handleFormSubmit.bind(this);\n    this.next = this.next.bind(this);\n    this.nextInstruction = this.nextInstruction.bind(this);\n    this.finishRepeat = this.finishRepeat.bind(this);\n    this.addRepeat = this.addRepeat.bind(this);\n    this.handleRepeatChange = this.handleRepeatChange.bind(this);\n    this.onKeyPressed = this.onKeyPressed.bind(this);\n  }\n\n  componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyPressed);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyPressed);\n  }\n\n  // for keyboard shortcuts\n  onKeyPressed(e) {\n    // ignore keys when inputting pattern\n    if (e.target.tagName === 'TEXTAREA' || this.state.pattern === undefined) return;\n    \n    switch(e.key) {\n      case \" \":\n        e.preventDefault();\n        this.next();\n        break;\n      case \"c\":\n        if (this.state.repeats.length > 0) this.addRepeat();\n        break;\n      case \"v\":\n        if (this.state.repeats.length > 0) this.finishRepeat();\n        break;\n      default: \n        return;\n    }\n  }\n  \n  handleFormChange(e) {\n    this.setState({patternInput: e.target.value});\n  }\n\n  handleFormSubmit(e) {\n    e.preventDefault();\n    \n    // is tokenized pattern valid(ish)?\n    const pattern = PatternLexer.tokenize(this.state.patternInput);\n    const err = PatternLexer.isInvalid(pattern);\n    if (err) {\n      alert(\"Pattern Syntax Error: \" + err + \".\");\n      return;\n    } \n\n    this.setState({\n      pattern: pattern,\n      instrIndex: 0,\n      tokIndex: 0,\n      finished: false,\n      repeats: [],\n    }, () => {\n      if (pattern[0][0].type !== TokenType.STR) this.next(); // start on first string\n    }); \n    \n  }\n\n  // advance to next string. Use transState and transNext to quickly advance state multiple times\n  // synchronously. \n  next() {\n    this.setState( prevState => {\n\n      let transState = {\n        pattern: prevState.pattern,\n        instrIndex: prevState.instrIndex,\n        tokIndex: prevState.tokIndex,\n        repeats: JSON.parse(JSON.stringify(prevState.repeats)),\n        finished: prevState.finished,\n      }\n      \n      transNext(transState);\n\n      return {...transState};\n    });\n  }\n\n  // complete 1 repeat. Do this by advancing (next()) over and over until we see that the repeat\n  // array in state has changed. Use transState/transNext to quickly advance through state synchronously.\n  addRepeat() {\n    // go 'next()' until repeat status in state changes\n    this.setState( prevState => {\n\n      let transState = {\n        pattern: prevState.pattern,\n        instrIndex: prevState.instrIndex,\n        tokIndex: prevState.tokIndex,\n        repeats: JSON.parse(JSON.stringify(prevState.repeats)),\n        finished: prevState.finished,\n      }\n      \n      const repeatIndex = transState.repeats.length - 1;\n      const numRepeats = transState.repeats[repeatIndex].numRepeats;\n\n      do { \n        transNext(transState);\n      } while (!transState.finished \n        && transState.repeats[repeatIndex] \n        && numRepeats === transState.repeats[repeatIndex].numRepeats)\n\n      return {...transState};\n    });\n  }\n\n  // breka out of current repeat by setting current index ahead of next ')' and \n  // popping the repeat stack.\n  finishRepeat() {\n    const instruction = this.state.pattern[this.state.instrIndex];\n    let i = this.state.tokIndex;\n    do {\n      i++\n    } while (instruction[i].type !== TokenType.CLS_PAREN);\n  \n    this.setState({\n      tokIndex: i + 1,\n      repeats: JSON.parse(JSON.stringify(this.state.repeats.slice(0, -1))),\n    }, () => {\n      if (instruction[i + 1].type !== TokenType.STR) this.next(); // leave us off at next string\n    })\n  }\n\n  // skip to next instruction in the pattern\n  nextInstruction() {\n    const pattern = this.state.pattern;\n    if(this.state.instrIndex >= pattern.length - 1) {\n      // already at last pattern\n      this.setState({finished: true});\n      return;\n    }\n\n    let nextInstrIndex = this.state.instrIndex + 1;\n    let nextTokIndex = 0;\n    \n    this.setState({\n      instrIndex: nextInstrIndex,\n      tokIndex: nextTokIndex,\n      repeats: [],\n    }, () => {\n      if (pattern[nextInstrIndex][nextTokIndex].type !== TokenType.STR) {\n        this.next(); // start at first string\n      }\n    })\n  }\n\n  // change count inside of repeats[index] when user manually changes it.\n  handleRepeatChange(index, event) {\n    let newVal = event.target.value;\n    if (newVal.match(/\\D/)) {\n      // Don't accept non-numeric chars\n      return;\n    }   \n    newVal = parseInt(newVal); // NaN if empty string\n\n    let newRepeats = JSON.parse(JSON.stringify(this.state.repeats));\n    newRepeats[index].numRepeats = newVal ? newVal : 0;\n    this.setState({\n      repeats: newRepeats,\n    })\n    return;\n  }\n\n  render() {\n    let display = null;\n    // has pattern been inputted by user yet? do we have any repeats (if not, don't display repeat buttons)? \n    if (this.state.pattern !== undefined) {\n      display = (\n        <div>\n          <div>\n            <InstructionView instruction={this.state.pattern[this.state.instrIndex]} tokIndex={this.state.tokIndex} repeats={this.state.repeats} onRepeatChange={this.handleRepeatChange}/>\n          </div>  \n          <div className='button-menu'>\n            <button onClick={this.next}>Next (Space)</button>\n            <button onClick={this.nextInstruction}>Next Instruction</button>  \n            {this.state.repeats.length > 0 ? <button onClick={this.addRepeat}>Complete Repeat (c)</button> : null}\n            {this.state.repeats.length > 0 ? <button onClick={this.finishRepeat}>Exit repeat (v)</button> : null}\n          </div>\n        </div>\n      )\n    }\n    \n    return (\n      <div>\n        {display}\n        <PatternForm value={this.state.patternInput} onChange={this.handleFormChange} onSubmit={this.handleFormSubmit}/>\n      </div>  \n    );\n  }\n}\n\n// ====== static methods ======\n\n// Call when we are at a ')' to see if we are ready to finish repeating\nfunction needToRepeat(instruction, index, numRepeats) {\n  \n  // assumes we are at ')' token\n  if (instruction[index].type !== TokenType.CLS_PAREN) console.log(\"fxn needToRepeat!!!!!\");\n  \n  // if no multiplier, repeat indefinitely within ()'s\n  if (instruction[index + 1] && instruction[index + 1].type !== TokenType.REP) {\n    return true;\n  }\n  \n  // do we have (sequence) * NUM ?\n  if (instruction[index + 2] && instruction[index + 2].type === TokenType.NUM) {\n    return numRepeats < Number(instruction[index + 2].value) - 1;\n  }\n  \n  // we don't have (sequence) * NUM\n  return true;\n}\n\n// advances to next token using repeat logic. if no next token, go to next instruction.\n// 'static' method. mutates transState to avoid problems with asynchronous setState.\nfunction advance(transState) {\n  let {pattern, instrIndex, tokIndex, finished} = transState;\n  let repeats = transState.repeats.slice();\n\n  if (pattern[instrIndex][tokIndex].type === TokenType.OPN_PAREN) {\n    // '(': create new repeat\n    repeats.push({index: tokIndex, numRepeats: 0});\n    tokIndex++;\n  } else if (pattern[instrIndex][tokIndex].type === TokenType.CLS_PAREN) {\n    // ')' do we continue or repeat?\n    if (needToRepeat(pattern[instrIndex], tokIndex, repeats[repeats.length - 1].numRepeats)){\n      // go back to beginning of repeat\n      tokIndex = repeats[repeats.length-1].index + 1;\n      repeats[repeats.length - 1].numRepeats++;\n    } else {\n      // finish repeat\n      repeats.pop();\n      tokIndex++;\n    }\n\n  } else {\n    tokIndex++;\n  }\n\n  if (!pattern[instrIndex][tokIndex]) {\n    // need to move on to next instruction\n    if(instrIndex >= pattern.length - 1) {\n      // already on last instruction\n      tokIndex = transState.tokIndex;\n      repeats = transState.repeats.slice();\n      finished = true;\n    } else {\n      instrIndex++;\n      tokIndex = 0;\n    }\n  }\n\n  transState.pattern = pattern;\n  transState.instrIndex = instrIndex;\n  transState.tokIndex = tokIndex;\n  transState.repeats = repeats;\n  transState.finished = finished;\n\n}\n\n// advances to next string \n// 'static' method. mutates transState to avoid problems with asynchronous setState.\nfunction transNext(transState) {\n  const initInstr = transState.instrIndex;\n  const initTok = transState.tokIndex;\n  const initReps = JSON.parse(JSON.stringify(transState.repeats));\n  \n  do {\n    advance(transState);\n  } while (transState.pattern[transState.instrIndex][transState.tokIndex].type !== TokenType.STR\n    && !transState.finished);\n\n  if (transState.finished) {\n    transState.instrIndex = initInstr;\n    transState.tokIndex = initTok;\n    transState.repeats = initReps;\n  }\n} \n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// import tester from './tester';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// tester();\n"],"sourceRoot":""}